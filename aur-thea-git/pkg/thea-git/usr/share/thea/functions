#!/bin/zsh
# THEA BACKUP SCRIPTS
# 
# Helper functions

# Parse all command line arguments
# Take appropriate action if arguments include generic options, such as --help or --quiet
# Then, put the rest of the arguments in $params
function parseargs() {
	declare -a local options
	local i

	shift
	zparseopts -a options -D -E -help -color -nocolor -quiet

	for i in ${options}
	do
		case ${i} in
			"--help")
				usage
				;;
			"--color")
				echof_color=1
				;;
			"--nocolor")
				echof_color=0
				;;
			"--quiet")
				echof_silent=1
		esac
	done

	for i in ${*}
	do
		params+=("${i}")
	done

	export params
}

# After calling parseopts(), all scripts should use $params in the place of $@
declare -a params

# Sanitize the environment for printing usage help
# Should be the first statement of all script-specific usage() functions
function usage_pre() {
	echof_date=0
	echof_silent=0
	echof_color=1
	maybe_disable_color
}

# Print generic usage options
# Should be the last statement of all script-specific usage() functions
function usage_post() {
	echof "Valid options are:" "info"
	echof "--help\t\tDisplay this help message" "info"
	echof "--color\t\tUse color output" "info"
	echof "--nocolor\t\tDo not use color output" "info"
	echof "--quiet\t\tBe quiet; do not print anything to standard output" "info"
}

# Exit script if GUI is not running
function check_gui() {
	xset -q >> /dev/null 2>> /dev/null
	if [ $? -ne 0 ]
	then
		echo "This program should only be launched from within the GUI"
		exit 8
	fi
}

# Disable color output if stdout is not a color capable terminal
function maybe_disable_color() {
	if [[ ! -t 1  || "$(tput colors)" -lt 8 ]]
	then
		echof_color=0
	fi
}

# Set terminal title to $1
function set_term_title() {
	xset -q >> /dev/null 2>> /dev/null
	if [ $? -eq 0 ]
	then
		echo -ne "\033]0;${1}\007"
	fi
}

# Fancy echo
# Print date or a * at the beginning of line (depending on whether $echof_date is set to 1 or not)
# Then, print $1 in different colors, depending on the value of $2 (green if "ok", red if "error", cyan if "heading", white otherwise)
# If $echof_silent is set to 1, do not print anything
function echof() {
	if [ ${echof_silent} -eq 1 ]
	then
		return
	fi

	[ ${echof_color} -eq 1 ] && echo -e "$(tput bold)$(tput setaf 3)\c"

	if [ ${echof_date} -eq 1 ]
	then
		echo -e "$(date +'%D %T'):\c"
	else
		echo -e "*\c"
	fi

	if [ "."${2} = ".heading" ]
	then
		[ ${echof_color} -eq 1 ] && echo -e "$(tput setaf 6)\c"
	elif [ "."${2} = ".error" ]
	then
		[ ${echof_color} -eq 1 ] && echo -e "$(tput setaf 1)\c"
	elif [ "."${2} = ".ok" ]
	then
		[ ${echof_color} -eq 1 ] && echo -e "$(tput setaf 2)\c"
	else
		[ ${echof_color} -eq 1 ] && echo -e "$(tput sgr0)\c"
	fi

	echo -e " ${1}\c"
	[ ${echof_color} -eq 1 ] && echo -e "$(tput sgr0)\c"
	echo -e ""
}

# Let the user press ENTER to Exit
function press_to_exit() {
	echo ""
	[ ${echof_color} -eq 1 ] && echo -e "$(tput bold)$(tput setaf 3)\c"
	echo -e "* \c"
	[ ${echof_color} -eq 1 ] && echo -e "$(tput sgr0) \c"
	echo -e "Press Enter to exit: \c"
	read
}

# Return 0 if the program specified in $1 is not running, number of active processes otherwise
function check_not_running()
{
	ret=$(ps aux | grep -e "${1} " | grep -v grep | grep -v $0 | wc -l | tr -s "\n")
	return $ret
}

# Return 0 if the backup volume is mounted
function check_if_mounted() {
	mount | grep "on ${BACKUP_VOLUME} type" >> /dev/null
	return $?
}

# Write rsnapshot's configuration file
# Note that this function should be run as root
function do_config() {
	local config_data="# Configuration file automatically generated by thea-config

config_version		1.2
snapshot_root		${BACKUP_VOLUME}
no_create_root		1
cmd_cp			/usr/bin/cp
cmd_rm			/usr/bin/rm
cmd_rsync		/usr/bin/rsync
cmd_ssh			/usr/bin/ssh
cmd_logger		/usr/bin/logger
cmd_du			/usr/bin/du
cmd_rsnapshot_diff	/usr/bin/rsnapshot-diff
interval		${RSNAPSHOT_INTERVAL}	${RSNAPSHOT_SNAPSHOTS}
verbose			3
loglevel		3
logfile			/var/log/rsnapshot
lockfile		/var/run/rsnapshot.pid
rsync_short_args	-a
rsync_long_args		--delete --numeric-ids --relative --delete-excluded
du_args			-csh
exclude			/mnt
exclude			/media
exclude			/proc
exclude			/sys
exclude			/tmp
exclude			/run/user
link_dest		1
backup			${RSNAPSHOT_POINT[1]}	${RSNAPSHOT_POINT[2]}"

	if [[ -f "${RSNAPSHOT_CONFIG}" && ! -f "${RSNAPSHOT_CONFIG}.orig" ]]
	then
		echof "Moving original configuration file to ${RSNAPSHOT_CONFIG}.orig" "info"
		mv "${RSNAPSHOT_CONFIG}" "${RSNAPSHOT_CONFIG}.orig"
		if [ $? -ne 0 ]
		then
			echof "Error moving original configuration file" "error"
			return 1
		fi
	fi

	echof "Writing configuration to ${RSNAPSHOT_CONFIG}" "info"
	echo "${config_data}" >"${RSNAPSHOT_CONFIG}"
	if [ $? -ne 0 ]
	then
		echof "Error writing configuration to ${RSNAPSHOT_CONFIG}" "error"
		return 2
	fi

	echof "Configuration written to ${RSNAPSHOT_CONFIG}" "ok"
	return 0
}

# Execute the pre-mount command
function do_mount_pre_cmd() {
	sudo_to_use=${1}
	if [ "."${sudo_to_use} = "." ]
	then
		sudo_to_use="sudo"
	fi

	if [ ".$MOUNT_PRE_CMD" != "." ]
	then
		echof "Executing command(s) before mount" "info"
		eval "${sudo_to_use} ${MOUNT_PRE_CMD}"
	fi
}

# Mount backup volume
# Return 0 on success, 1 on failure, 2 if already mounted
# $1 designates sudo command to use (ie "sudo" or "gksudo")
function do_mount() {
	sudo_to_use=${1}
	if [ "."${sudo_to_use} = "." ]
	then
		sudo_to_use="sudo"
	fi

	check_not_running ${RSNAPSHOT_CMD}
	if [ $? -ne 0 ]
	then
		echof "Cannot proceed while ${RSNAPSHOT_CMD} is running" "error"
		return 1
	fi

	check_if_mounted
	if [ $? -ne 0 ]
	then
		echof "Backup volume ${BACKUP_VOLUME} is not mounted" "info"
		do_mount_pre_cmd ${sudo_to_use}
		echof "Attempting to mount" "info"
		${sudo_to_use} mount ${BACKUP_VOLUME}
		if [ $? -ne 0 ]
		then
			echof "Unable to mount backup volume" "error"
			return 1
		else
			echof "Backup volume is now mounted" "ok"
			return 0
		fi
	else
		echof "Backup volume ${BACKUP_VOLUME} is already mounted" "info"
		return 2
	fi
}

# Execute the post-umount command
function do_umount_post_cmd() {
	sudo_to_use=${1}
	if [ "."${sudo_to_use} = "." ]
	then
		sudo_to_use="sudo"
	fi

	if [ ".$UMOUNT_POST_CMD" != "." ]
	then
		echof "Executing command(s) after unmount" "info"
		eval "${sudo_to_use} ${UMOUNT_POST_CMD}"
	fi
}

# Unmount the backup volume
# Return 0 on success, 1 on failure, 2 if already unmounted
# $1 designates sudo command to use (ie "sudo" or "gksudo")
function do_umount() {
	sudo_to_use=${1}
	if [ "."${sudo_to_use} = "." ]
	then
		sudo_to_use="sudo"
	fi

	check_not_running ${RSNAPSHOT_CMD}
	if [ $? -ne 0 ]
	then
		echof "Cannot proceed while ${RSNAPSHOT_CMD} is running" "error"
		return 1
	fi

	check_if_mounted
	if [ $? -eq 0 ]
	then
		echof "Backup volume ${BACKUP_VOLUME} is mounted" "info"
		echof "Attempting to unmount" "info"
		${sudo_to_use} umount ${BACKUP_VOLUME}
		if [ $? -ne 0 ]
		then
			echof "Unable to unmount backup volume" "error"
			return 1
		else
			do_umount_post_cmd ${sudo_to_use}
			echof "Backup volume has been unmounted" "ok"
			return 0
		fi
	else
		echof "Backup volume ${BACKUP_VOLUME} is not mounted" "info"
		return 2
	fi
}

# Execute the pre-backup command
function do_backup_pre_cmd() {
	sudo_to_use=${1}
	if [ "."${sudo_to_use} = "." ]
	then
		sudo_to_use="sudo"
	fi

	if [ ".$BACKUP_PRE_CMD" != "." ]
	then
		echof "Executing command(s) before backup" "info"
		eval "${sudo_to_use} ${BACKUP_PRE_CMD}"
	fi
}

# Execute the post-backup command
function do_backup_post_cmd() {
	sudo_to_use=${1}
	if [ "."${sudo_to_use} = "." ]
	then
		sudo_to_use="sudo"
	fi

	if [ ".$BACKUP_POST_CMD" != "." ]
	then
		echof "Executing command(s) after backup" "info"
		eval "${sudo_to_use} ${BACKUP_POST_CMD}"
	fi
}

# Perform a backup
# Return 0 on success, 1 on failure
# $1 designates sudo command to use (ie "sudo" or "gksudo")
function do_backup() {
	sudo_to_use=${1}
	if [ "."${sudo_to_use} = "." ]
	then
		sudo_to_use="sudo"
	fi

	check_not_running ${RSNAPSHOT_CMD}
	if [ $? -ne 0 ]
	then
		echof "Cannot proceed while ${RSNAPSHOT_CMD} is running" "error"
		return 1
	fi

	echof "Executing backup command (${RSNAPSHOT_CMD})" "info"
	${sudo_to_use} ${RSNAPSHOT_CMD} ${RSNAPSHOT_CMD_ARGS} ${RSNAPSHOT_INTERVAL}
	if [ $? -eq 1 ]
	then
		echof "Backup failed" "error"
		return 1
	elif [ $? -eq 2 ]
	then
		echof "Backup command has issued some warnings; you chould investigate" "info"
		echof "Backup complete" "ok"
		return 0
	else
		echof "Backup complete" "ok"
		return 0
	fi
}

# Suspend the computer, power off the computer, or wait for key press after a backup
function post_backup_action() {
	if [ ".${1}" = ".andsleep" ]
	then
		sudo ${SUSPEND_CMD} ${SUSPEND_CMD_ARGS}
		press_to_exit
	elif [ ".${1}" = ".andpoweroff" ]
	then
		sudo ${POWEROFF_CMD} ${POWEROFF_CMD_ARGS}
		press_to_exit
	elif [ ".${1}" = ".andpause" ]
	then
		press_to_exit
	fi
}

# Put a type description of file $1 in $ret
function file_prefix() {
	if [ -d "${1}" ]
	then
		local prefix="directory"
	elif [ -L "${1}" ]
	then
		local prefix="simlink"
	elif [ -b "${1}" ]
	then
		local prefix="block special file"
	elif [ -c "${1}" ]
	then
		local prefix="character special file"
	elif [ -p "${1}" ]
	then
		local prefix="named pipe"
	elif [ -S "${1}" ]
	then
		local prefix="socket"
	elif [ -f "${1}" ]
	then
		local prefix="file"
	else
		local prefix="weird file"
	fi

	ret=${prefix}
}

# Put a short type description of file $1 in $ret
function file_iprefix() {
	if [ -d "${1}" ]
	then
		local iprefix="[d] "
	elif [ -L "${1}" ]
	then
		local iprefix="[l] "
	elif [ -b "${1}" ]
	then
		local iprefix="[b] "
	elif [ -c "${1}" ]
	then
		local iprefix="[c] "
	elif [ -p "${1}" ]
	then
		local iprefix="[p] "
	elif [ -S "${1}" ]
	then
		local iprefix="[s] "
	elif [ -f "${1}" ]
	then
		local iprefix="[f] "
	else
		local iprefix="[?] "
	fi

	ret=${iprefix}
}

# Quickly compare two versions of a file, specified in $1 and $2
# Return 0 if they are the same, 1 otherwise
function quickcmp() {
	local file1="${1}"
	local file2="${2}"
	local size1="$(stat -c%s "${file1}" 2>>/dev/null)"
	local size2="$(stat -c%s "${file2}" 2>>/dev/null)"
	local i
	declare -a local ifiles

	if [[ -e "${file1}" && ! -e "${file2}" ]]
	then
		return 1
	fi

	if [[ ! -e "${file1}" && -e "${file2}" ]]
	then
		return 1
	fi

	if [ -d "${file1}" ]
	then
		if [ ! -d "${file2}" ]
		then
			return 1
		fi

		ifiles=("${file1}"/*(N) "${file1}"/.*(N))
		if [ ${#ifiles} -gt 0 ]
		then
			for i in ${ifiles}
			do
				local ifile1="$(readlink -f "$i" 2>>/dev/null)"
				local ibase1="$(basename "${ifile1}" 2>>/dev/null)"
				local ifile2="$(readlink -f "${file2}/${ibase1}" 2>>/dev/null)"

				if [ ! -e "${ifile2}" ]
				then
					return 1
				fi

				quickcmp "${ifile1}" "${ifile2}"
				if [ $? -ne 0 ]
				then
					return 1
				fi
			done
		fi

		ifiles=("${file2}"/*(N) "${file2}"/.*(N))
		if [ ${#ifiles} -gt 0 ]
		then
			for i in ${ifiles}
			do
				local ifile1="$(readlink -f "$i" 2>>/dev/null)"
				local ibase1="$(basename "${ifile1}" 2>>/dev/null)"
				local ifile2="$(readlink -f "${file2}/${ibase1}" 2>>/dev/null)"

				if [ ! -e "${ifile1}" ]
				then
					return 1
				fi
			done
		fi

		return 0
	fi

	if [[ ${size1} -eq ${size2} && ! "${file1}" -ot "${file2}" && ! "${file1}" -nt "${file2}" ]]
	then
		return 0
	fi

	cmp -s "${file1}" "${file2}" >>/dev/null 2>>/dev/null
	return $?
}

# Produce a stylized diff of two directories, specified in $1 and $2
# Put results in $ret
function dirdiff() {
	local file="${1}"
	local filebak="${2}"
	local diffs=""
	local i
	declare -a local ifiles

	ifiles=("${file}"/*(N) "${file}"/.*(N))
	if [ ${#ifiles} -gt 0 ]
	then
		for i in ${ifiles}
		do
			local ifile="$(readlink -f "$i" 2>>/dev/null)"
			local ibase="$(basename "${ifile}" 2>>/dev/null)"
			local ifilebak="$(readlink -f "${filebak}/${ibase}" 2>>/dev/null)"

			local isize="$(stat -c%s "${ifile}" 2>>/dev/null)"
			local isizebak="$(stat -c%s "${ifilebak}" 2>>/dev/null)"

			file_iprefix "${ifile}"
			local iprefix=${ret}

			if [ ! -e "${ifilebak}" ]
			then
				diffs="${diffs}${iprefix}${ibase} (${isize} bytes) is "
				[ ${echof_color} -eq 1 ] && diffs="${diffs}$(tput bold)$(tput setaf 1)"
				diffs="${diffs}not in backup\n"
				[ ${echof_color} -eq 1 ] && diffs="${diffs}$(tput sgr0)"

			else
				quickcmp "${ifile}" "${ifilebak}"
				if [ $? -eq 1 ]
				then
					diffs="${diffs}${iprefix}${ibase} (${isize} bytes) is "
					[ ${echof_color} -eq 1 ] && diffs="${diffs}$(tput bold)$(tput setaf 5)"
					diffs="${diffs}different in backup\n"
					[ ${echof_color} -eq 1 ] && diffs="${diffs}$(tput sgr0)"
				fi
			fi
		done
	fi

	ifiles=("${filebak}"/*(N) "${filebak}"/.*(N))
	if [ ${#ifiles} -gt 0 ]
	then
		for i in ${ifiles}
		do
			local ifilebak="$(readlink -f "$i" 2>>/dev/null)"
			local ibasebak="$(basename "${ifilebak}" 2>>/dev/null)"
			local ifile="$(readlink -f "${file}/${ibasebak}" 2>>/dev/null)"

			local isizebak="$(stat -c%s "${ifilebak}" 2>>/dev/null)"
			local isize="$(stat -c%s "${ifile}" 2>>/dev/null)"

			file_iprefix "${ifilebak}"
			local iprefix=${ret}

			if [ ! -e "${ifile}" ]
			then
				diffs="${diffs}${iprefix}${ibasebak} (${isizebak} bytes) is "
				[ ${echof_color} -eq 1 ] && diffs="${diffs}$(tput bold)$(tput setaf 3)"
				diffs="${diffs}deleted but in backup\n"
				[ ${echof_color} -eq 1 ] && diffs="${diffs}$(tput sgr0)"
			fi
		done
	fi

	ret="${diffs}"
}

# Search and print the differences between the file specified in $1 and a backed up version of the same file
# $2 denotes the snapshot number in which to look for the said backed up version
# Return 0 if files are identical, 1 if different, 2 if not in backup, 3 if deleted but in backup, 4 if unable to compare, 5 in case of error
function do_diff() {
	local snapshotdir="${BACKUP_VOLUME}/${RSNAPSHOT_INTERVAL}.${2}/${RSNAPSHOT_POINT[2]}"
	local file="$(readlink -f "${1}" 2>>/dev/null)"
	local filebak="$(readlink -f "${snapshotdir}/${file}" 2>>/dev/null)"

	local size="$(stat -c%s "${file}" 2>>/dev/null)"
	if [ "."${size} = "." ]
	then
		size=0
	fi
	local sizebak="$(stat -c%s "${filebak}" 2>>/dev/null)"
	if [ "."${sizebak} = "." ]
	then
		sizebak=0
	fi

	file_prefix "${file}"
	local prefix=${ret}

	local diffs

	echof "File: ${file}" "info"
	echof "Size: ${size} bytes" "info"
	echof "File type: ${prefix}" "info"
	echof "Snapshot no: ${2}" "info"

	if [[ ! -e "${file}" && ! -e "${filebak}" ]]
	then
		echof "Status: file not found" "error"
		return 5
	elif [[ ! -e "${file}" && -e "${filebak}" ]]
	then
		echof "Status: deleted but in backup" "heading"
		return 3
	elif [[ -e "${file}" && ! -e "${filebak}" ]]
	then
		echof "Status: not in backup" "heading"
		return 2
	else
		if [ -d "${file}" ]
		then
			dirdiff "${file}" "${filebak}"
			diffs="${ret}"

			if [ ".${diffs}" = "." ]
			then
				echof "Status: identical in backup" "heading"
				return 0
			else
				echof "Status: different in backup" "heading"
				echof "Differences:\n$(echo "${diffs}" | tr -s "\n")" "info"
				return 1
			fi
		elif [ -f "${file}" ]
		then
			quickcmp "${file}" "${filebak}"
			if [ $? -eq 0 ]
			then
				echof "Status: identical in backup" "heading"
				return 0
			else
				if [ ${echof_color} -eq 1 ] 
				then
					diffs="$(colordiff "${file}" "${filebak}")"
				else
					diffs="$(diff "${file}" "${filebak}")"
				fi
				echof "Status: different in backup" "heading"
				echof "Size in backup: ${sizebak} bytes" "info"
				echof "Differences:\n${diffs}" "info"
				return 1
			fi
		else
			echof "Status: in backup (but unable to compare)" "heading"
			echof "Size in backup: ${sizebak} bytes" "info"
			return 4
		fi
	fi
}

# Summarize the differences between the file specified in $1 and all its backed up versions
# Return 1 in case of error, otherwise 0
do_summary() {
	local file="$(readlink -f "${1}" 2>>/dev/null)"
	local size="$(stat -c%s "${file}" 2>>/dev/null)"

	file_prefix "${file}"
	local prefix=${ret}

	echof "File: ${file}" "info"
	echof "Size: ${size} bytes" "info"
	echof "File type: ${prefix}" "info"

	local summary=""
	local sstatus=""
	summary="${summary}Snapshot|Size in backup      |Status\n"
	summary="${summary}--------|--------------------|---------------------------------\n"
	for ((i=0; i < ${RSNAPSHOT_SNAPSHOTS}; i++))
	do
		local snapshotdir="${BACKUP_VOLUME}/${RSNAPSHOT_INTERVAL}.${i}/${RSNAPSHOT_POINT[2]}"
		local filebak="$(readlink -f "${snapshotdir}/${file}" 2>>/dev/null)"

		local sizebak="$(stat -c%s "${filebak}" 2>>/dev/null)"
		if [ "."${sizebak} = "." ]
		then
			sizebak=0
		fi
	
		if [[ ! -e "${file}" && ! -e "${filebak}" ]]
		then
			if [ ${echof_color} -eq 1 ]
			then
				sstatus="${diffs}$(tput bold)$(tput setaf 1)deleted and not in backup$(tput sgr0)"
			else
				sstatus="deleted and not in backup"
			fi
		elif [[ ! -e "${file}" && -e "${filebak}" ]]
		then
			if [ ${echof_color} -eq 1 ]
			then
				sstatus="${diffs}$(tput bold)$(tput setaf 3)deleted but in backup$(tput sgr0)"
			else
				sstatus="deleted but in backup"
			fi
		elif [[ -e "${file}" && ! -e "${filebak}" ]]
		then
			if [ ${echof_color} -eq 1 ]
			then
				sstatus="${diffs}$(tput bold)$(tput setaf 1)not in backup$(tput sgr0)"
			else
				sstatus="not in backup"
			fi
		else
			if [[ -d "${file}" || -f "${file}" ]]
			then
				quickcmp "${file}" "${filebak}"
				if [ $? -eq 0 ]
				then
					if [ ${echof_color} -eq 1 ]
					then
						sstatus="${diffs}$(tput bold)$(tput setaf 2)identical in backup$(tput sgr0)"
					else
						sstatus="identical in backup"
					fi
				else
					if [ ${echof_color} -eq 1 ]
					then
						sstatus="${diffs}$(tput bold)$(tput setaf 5)different in backup$(tput sgr0)"
					else
						sstatus="different in backup"
					fi
				fi
			else
			fi
		fi

		summary="${summary}${i}|${sizebak} bytes|${sstatus}\n"
	done

	echof "Status summary:" "heading"
	[ ${echof_silent} -ne 1 ] && echo "${summary}" | column -t -s\| | tr -s "\n"
	return 0
}

# Restore file specified in $1 from backup snapshot specified in $2
# The original version of $1 is saved in a new random file
# Return 1 if unable to restore, 2 if restore process fails, 0 on success
function do_restore() {
	local snapshotdir="${BACKUP_VOLUME}/${RSNAPSHOT_INTERVAL}.${2}/${RSNAPSHOT_POINT[2]}"
	local file="$(readlink -f "${1}" 2>>/dev/null)"
	local filedir="$(dirname "${file}" 2>>/dev/null)"
	local filebase="$(basename "${file}" 2>>/dev/null)"
	local filepre="$(mktemp -u --tmpdir="${filedir}" preserve.XXXXXXXXXX)"
	local filebak="$(readlink -f "${snapshotdir}/${file}" 2>>/dev/null)"

	local size="$(stat -c%s "${file}" 2>>/dev/null)"
	if [ "."${size} = "." ]
	then
		size=0
	fi
	local sizebak="$(stat -c%s "${filebak}" 2>>/dev/null)"

	file_prefix "${file}"
	local prefix=${ret}

	echof "File: ${file}" "info"
	echof "Size: ${size} bytes" "info"
	echof "File type: ${prefix}" "info"
	echof "Snapshot no: ${2}" "info"

	if [ ! -e "${filebak}" ]
	then
		echof "Cannot restore file that is not in backup" "error"
		return 1
	fi

	if [[ ! -f "${file}" && ! -d "${file}"  && ! -f "${filebak}" && ! -d "${filebak}" ]]
	then
		echof "Only regular files and directories can be restored" "error"
		return 1
	fi

	quickcmp "${file}" "${filebak}"
	if [ $? -eq 0 ]
	then
		echof "Cannot restore file that is identical to its backed up version" "error"
		return 1
	fi

	if [ -e ${file} ]
	then
		echof "Preserving original version of file in:" "info"
		echof "${filepre}" "info"
		mv "${file}" "${filepre}"
		if [ $? -ne 0 ]
		then
			echof "Move operation failed" "error"
			return 2
		fi
	fi

	echof "Copying backed up version of file to disk" "info"
	cp -a "${filebak}" "${file}"
	if [ $? -ne 0 ]
	then
		echof "Copy operation failed" "error"
		return 2
	fi

	echof "Restoration successful" "heading"
	return 0
}
